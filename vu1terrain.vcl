;/*
;* "PS2" Application Framework
;*
;* University of Abertay Dundee
;* May be used for educational purposed only
;*
;* Author - Dr Henry S Fortuna
;*
;* $Revision: 1.2 $
;* $Date: 2007/08/19 12:45:13 $
;*
;*/

; The static (or initialisation buffer) i.e. stuff that doesn't change for each
; time this code is called.
Scales		.assign 0
LightDirs	.assign 1
LightCols	.assign 5
Transform	.assign 9 
LightTrans	.assign 13
PointPos	.assign 17
PointCol	.assign 18

; The input buffer (relative the the start of one of the double buffers)
NumVerts	.assign 0 
GifPacket  	.assign	1 
UVStart		.assign 2
NormStart	.assign 3
VertStart	.assign 4

; The output buffer (relative the the start of one of the double buffers)
GifPacketOut	.assign 248
UVStartOut		.assign 249
NormStartOut	.assign 250
VertStartOut	.assign 251


; Note that we have 4 data buffers: InputBuffer0, OutputBuffer0, InputBuffer1, and OutputBuffer1.
; Each buffer is 248 quad words. The different buffers are selected by reading the current offset
; from xtop (which is swapped automatically by the PS2 after each MSCALL / MSCNT).


.include "vcl_sml.i"

.init_vf_all
.init_vi_all
.syntax new

.vu

--enter
--endenter

; The START or Init code, that is only called once per frame.
START:
	fcset		0x000000

	lq			fTransform[0], Transform+0(vi00)
	lq			fTransform[1], Transform+1(vi00)
	lq			fTransform[2], Transform+2(vi00)
	lq			fTransform[3], Transform+3(vi00)
	lq			fLightTrans[0], LightTrans+0(vi00)
	lq			fLightTrans[1], LightTrans+1(vi00)
	lq			fLightTrans[2], LightTrans+2(vi00)
	lq			fLightTrans[3], LightTrans+3(vi00)
	lq			fScales, Scales(vi00)

; This begin code is called once per batch
begin:
	xtop		iDBOffset		; Load the address of the current buffer (will either be QW 16 or QW 520)
	ilw.x		iNumVerts, NumVerts(iDBOffset)
	iadd		iNumVerts, iNumVerts, iDBOffset
	iadd		Counter, vi00, iDBOffset

loop:
	lq			fVert, VertStart(Counter)				; Load the vertex from the input buffer
	mul         acc,  fTransform[0],  fVert[x]			; Transform it
    madd        acc,  fTransform[1],  fVert[y]
    madd        acc,  fTransform[2],  fVert[z]
    madd        Vert, fTransform[3],  fVert[w]
    clipw.xyz	Vert, Vert								; Clip it
	fcand		vi01, 0x3FFFF
	iaddiu		iADC, vi01, 0x7FFF
	ilw.w		iNoDraw, UVStart(Counter)				; Load the iNoDraw flag. If true we should set the ADC bit so the vert isn't drawn
	iadd		iADC, iADC, iNoDraw
	isw.w		iADC, VertStartOut(Counter)
	div         q,    vf00[w], Vert[w]			
	lq			UV,   UVStart(Counter)					; Handle the tex-coords
	mul			UV,   UV, q
	sq			UV,   UVStartOut(Counter)
	mul.xyz     Vert, Vert, q							; Scale the final vertex to fit to the screen.
	mula.xyz	acc, fScales, vf00[w]
	madd.xyz	Vert, Vert, fScales
	ftoi4.xyz	Vert, Vert
	sq.xyz		Vert, VertStartOut(Counter)				; And store in the output buffer
	
	; Directional and Ambient Lighting
	lq			Norm, NormStart(Counter)				; Load the normal
	mul.xyz     acc,  fLightTrans[0],  Norm[x]			; Transform by the rotation part of the world matrix
    madd.xyz    acc,  fLightTrans[1],  Norm[y]
    madd.xyz    Norm, fLightTrans[2],  Norm[z]	
    lq.xyz		fLightDirs[0], LightDirs+0(vi00)		; Load the light directions
    lq.xyz		fLightDirs[1], LightDirs+1(vi00)
    lq.xyz		fLightDirs[2], LightDirs+2(vi00)
    mula.xyz	acc, fLightDirs[0], Norm[x]				; "Transform" the normal by the light direction matrix
    madd.xyz	acc, fLightDirs[1], Norm[y]				; This has the effect of outputting a vector with all
    madd.xyz	fIntensities, fLightDirs[2], Norm[z]	; four intensities, one for each light.
    mini.xyz	fIntensities, fIntensities, vf00[w]		; Clamp the intensity to 0..1
    max.xyz		fIntensities, fIntensities, vf00[x]

	; Point Light
	lq			fPointPos, PointPos(Counter)			; Load point light position
	lq			Norm, 	NormStart(Counter)				; Load the normal
	MatrixMultiplyVertex 	fPointPos, fLightTrans, fPointPos	; Transform the point light position into world space
	MatrixMultiplyVertex 	Norm, fLightTrans, Norm				; Transform normal into world space
	MatrixMultiplyVertex 	Vert, fLightTrans, fVert			; Transform vertex into world space
	sub.xyz		ToLight, fPointPos, Vert				; Get vector from the vertex to point light
	ersadd		p, ToLight								; Find length^2 of ToLight vector
	mfp.x		Distance, p	
	VectorNormalizeXYZ 	ToLight, ToLight				; Normalise this vector 
	VectorDotProduct 	fIntensity, ToLight, Norm		; Get the intensity
	loi 		9										; Intensify the point light effect
	mul.x		fIntensity, fIntensity, i
	mul.x		fIntensity, fIntensity, fIntensity		
	mul.x		fIntensity, fIntensity, fIntensity					
	mul.x		fIntensity, fIntensity, Distance		; Fade out with distance squared
	max.x		fIntensity, fIntensity, vf00			; Clamp to > 0
	mini.x		fIntensity, fIntensity, vf00[w]			; Clamp to < 1
	
	
	lq.xyz		fLightCols[0], LightCols+0(vi00)		; Load the light colours
    lq.xyz		fLightCols[1], LightCols+1(vi00)
    lq.xyz		fLightCols[2], LightCols+2(vi00)
    lq.xyz		fAmbient, LightCols+3(vi00)
	lq.xyz		fPointCol, PointCol(vi00)				; Load the point light colour
	
	; Point Light only
;	mul.xyz		fPointCol, fPointCol, fIntensity[x]		; Scale the colour by the intensity

;	loi		128
;	mul		fPointCol, fPointCol, i						; Scale values from 0-1 to 0-128
;	ftoi0	iPointCol, fPointCol						; Convert to int

;	sq   	iPointCol, NormStartOut(Counter)			; And write to the output buffer

	; Combined Lighting
	mula.xyz	acc, fLightCols[0], fIntensities[x]		; Transform the intensities by the light colour matrix
	madda.xyz	acc, fLightCols[1], fIntensities[y]		; This gives the final total directional light colour
	madda.xyz	acc, fLightCols[2], fIntensities[z]
	madda.xyz	acc, fPointCol, fIntensity[x]			; Scale the point colour by the point intensity
	madd.xyz	fIntensities, fAmbient, vf00[w]
	loi			128										; Load 128 and put it into the alpha value
	addi.w		fIntensities, vf00, i
	ftoi0   	iIntensities, fIntensities				; Convert to ints
	sq   		iIntensities, NormStartOut(Counter)		; And write to the output buffer

	
	iaddiu		Counter, Counter, 3
	ibne		Counter, iNumVerts, loop				; Loop until all of the verts in this batch are done.
	iaddiu		iKick, iDBOffset, GifPacketOut
	lq			GP, GifPacket(iDBOffset)				; Copy the GIFTag to the output buffer
	sq			GP, GifPacketOut(iDBOffset)
	xgkick		iKick									; and render!
	
--cont
														; --cont is like end, but it really means pause, as this is where the code
														; will pick up from when MSCNT is called.
	b			begin									; Which will make it hit this code which takes it back to the start, but
														; skips the initialisation which we don't want done twice.

--exit
--endexit
